/**
* packetcapture API generated from packetcapture.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


#include <string>
#include <sys/time.h>
#include <iomanip>
#include <iostream>
#include <ctime>
#include <fstream>
#include "unistd.h"
#include "Packetcapture.h"
<<<<<<< HEAD
#include "Packetcapture_dp_ingress.h"
#include "Packetcapture_dp_egress.h"
#define ON_T 0
#define OFF_T 1

=======
#include "Packetcapture_dp.h"
#include <string>
>>>>>>> Packet filters application

typedef int bpf_int32; 
typedef u_int bpf_u_int32;

struct pcap_file_header {
  bpf_u_int32 magic;      /* magic number */
  u_short version_major;  /* major version number */
  u_short version_minor;  /* minor version number */
  bpf_int32 thiszone;     /* GMT to local correction */
  bpf_u_int32 sigfigs;    /* accuracy of timestamps */
  bpf_u_int32 snaplen;    /* max length of captured packets, in octets */
  bpf_u_int32 linktype;   /* data link type */
};

struct pcap_pkthdr {
  bpf_u_int32 ts_sec;
  bpf_u_int32 ts_usec;  
  bpf_u_int32 caplen;     /* number of octets of packet saved in file */
  bpf_u_int32 len;        /* actual length of packet */
};



Packetcapture::Packetcapture(const std::string name, const PacketcaptureJsonObject &conf)
  : TransparentCube(conf.getBase(), { packetcapture_code_ingress }, { packetcapture_code_egress }),
    PacketcaptureBase(name) {
  logger()->info("Creating Packetcapture instance");
    setCapture(conf.getCapture());
    setAnomimize(conf.getAnomimize());

  if (conf.dumpIsSet()) {
    setDump(conf.getDump());
  }

  setNetworkmode(conf.getNetworkmode());
  addFilters(conf.getFilters());
  addGlobalheader(conf.getGlobalheader());
  CapStatus = (uint8_t) conf.getCapture();

  auto t_filters_in = get_array_table<filters_table>("filters_map", 0, ProgramType::INGRESS);
  auto t_filters_out = get_array_table<filters_table>("filters_map", 0, ProgramType::EGRESS);
  filters_table ft_init;
  ft_init.dst_port_flag = ft_init.src_port_flag = ft_init.network_filter_src_flag = ft_init.network_filter_dst_flag = ft_init.l4proto_flag = false;
  t_filters_in.set(0x0, ft_init);
  t_filters_out.set(0x0, ft_init);
  writeHeader = true;
  dt = "";
}

void Packetcapture::writeDump(const std::vector<uint8_t> &packet,
    const packetHeaders &pkt_values){
  PacketJsonObject pj;
  auto p = std::shared_ptr<Packet>(new Packet(*this, pj));
  struct timeval tp;
  std::streamsize len;

  if( dt == "" ){
    time_t now = time(0);
    tm *ltm = localtime(&now);
    std::stringstream tmstmp;
    tmstmp << ltm->tm_mday << "-" << ltm->tm_mon << "-" << (ltm->tm_year + 1900) << "-" << ltm->tm_hour << ":" << ltm->tm_min << ":" << ltm->tm_sec;
    dt = tmstmp.str();
  }
  
  myFile.open("capture_"+ dt +".pcap", std::ios::binary | std::ios::app);

  if( writeHeader == true ){
    struct pcap_file_header *pcap_header = new struct pcap_file_header;
    pcap_header->magic = global_header->getMagic();
    pcap_header->version_major = global_header->getVersionMajor();
    pcap_header->version_minor = global_header->getVersionMinor();
    pcap_header->thiszone = global_header->getThiszone();   //timestamp are always in GMT
    pcap_header->sigfigs = global_header->getSigfigs();
    pcap_header->snaplen = filters->getSnaplen();
    pcap_header->linktype = global_header->getLinktype();

    myFile.write(reinterpret_cast<const char*>(pcap_header), sizeof(*pcap_header));
    writeHeader = false;
  }
  gettimeofday(&tp, NULL);
  p->setTimestampSeconds((uint32_t) tp.tv_sec);
  p->setTimestampMicroseconds((uint32_t) tp.tv_usec);
  p->setPacketlen((uint32_t) packet.size());
  if(p->getPacketlen() > filters->getSnaplen()){
    p->setCapturelen(filters->getSnaplen());
  }else{
    p->setCapturelen(p->getPacketlen());
  }
  p->setRawPacketData(packet);

  struct pcap_pkthdr *pkt_hdr = new struct pcap_pkthdr;
  pkt_hdr->ts_sec = p->getTimestampSeconds();
  pkt_hdr->ts_usec = p->getTimestampMicroseconds();
  pkt_hdr->len = p->getPacketlen();
  pkt_hdr->caplen = p->getCapturelen();
  filters->getSnaplen() < p->getRawPacketData().size() ? len = filters->getSnaplen() : len = p->getRawPacketData().size();

  myFile.write(reinterpret_cast<const char*>(pkt_hdr), sizeof(*pkt_hdr));
  myFile.write(reinterpret_cast<const char*>(&p->getRawPacketData()[0]), len );
  myFile.close();
}

Packetcapture::~Packetcapture() {
  logger()->info("Destroying Packetcapture instance");
}

bool Packetcapture::filtering(const packetHeaders &pkt_values){
  bool pass = true;

  //source port filter   
  if( filters->srcPort_is_set() && (pkt_values.srcPort != filters->getSport()) ){
    pass = false;
    goto end;
  }
  
  //destination port filter
  if( filters->dstPort_is_set() && (pkt_values.dstPort != filters->getDport()) ){
    pass = false;
    goto end;
  }

  //layer 4 filter - TCP
  if( (filters->l4proto_is_set()) && (filters->getL4proto().compare(std::string("tcp")) == 0) && (pkt_values.l4proto != IPPROTO_TCP) ){
    pass = false;
    goto end;
  }

  //layer 4 filter - UDP
  if( (filters->l4proto_is_set()) && (filters->getL4proto().compare(std::string("udp")) == 0) && (pkt_values.l4proto != IPPROTO_UDP) ){
      pass = false;
      goto end;
    }
  
  //TODO: controllo su ip sorgente e ip destinazione
  if( filters->srcIp_is_set() ){
    uint32_t ip_src_filter = 0;
    uint32_t netmask_filter = (0xFFFFFFFF << (32 - std::stoi(filters->getSrc().substr(filters->getSrc().find("/")+1)))) & 0xFFFFFFFF;
    uint32_t network_filter, network_packet;
  
    std::string source_ip = filters->getSrc().substr(0, filters->getSrc().find("/"));
    //TODO: per controllare questo devo prima scrivere l'indirizzo ip dentro la struct packetHeaders. Scrivilo e poi testami.
    inet_pton(AF_INET, source_ip.data(), &ip_src_filter);
    ip_src_filter = ntohl(ip_src_filter); //todo: Valuta se rimuovere o meno questa riga. controlla se l'indirizzo ip arriva in network order
    
    
    //TODO: da testare da qui in giÃº
    logger()->debug("netmask: {0}", netmask_filter);
    logger()->debug("ip_src_filter: {0}", ip_src_filter);
    network_filter = ip_src_filter & netmask_filter;
    logger()->debug("indirizzo di rete del filtro: {0}", network_filter);

  }


end:
  return pass;
};

void Packetcapture::packet_in(polycube::service::Sense sense,
    polycube::service::PacketInMetadata &md,
    const std::vector<uint8_t> &packet) {
<<<<<<< HEAD
  
  Tins::EthernetII pkt(&packet[0], packet.size());
  packetHeaders pkt_values;
      
  switch (sense) {
    case polycube::service::Sense::INGRESS:
    pkt_values = get_array_table<packetHeaders>("pkt_header", 0, ProgramType::INGRESS).get(0x0);
    if( getNetworkmode() == true ){
      addPacket(packet, pkt_values);    /* store the packet */
    }else{
      writeDump(packet, pkt_values);
    }
    break;
    case polycube::service::Sense::EGRESS:
    pkt_values = get_array_table<packetHeaders>("pkt_header", 0, ProgramType::EGRESS).get(0x0);
    if( getNetworkmode() == true ){
      addPacket(packet, pkt_values);    /* store the packet */
    }else{
      writeDump(packet, pkt_values);
    }
    break;
  }
  send_packet_out(pkt, sense, false);
}

PacketcaptureCaptureEnum Packetcapture::getCapture() {
  return static_cast<PacketcaptureCaptureEnum>(CapStatus);
}

void Packetcapture::setCapture(const PacketcaptureCaptureEnum &value) {

  auto t_in = get_array_table<uint8_t>("working", 0, ProgramType::INGRESS);
  auto t_out = get_array_table<uint8_t>("working", 0, ProgramType::EGRESS);

  switch(value){
    case PacketcaptureCaptureEnum::INGRESS:
      t_in.set(0x0, ON_T);
      t_out.set(0x0, OFF_T);
      CapStatus = 0;
    break;
    case PacketcaptureCaptureEnum::EGRESS:
      t_in.set(0x0, OFF_T);
      t_out.set(0x0, ON_T);
      CapStatus = 1;
    break;
    case PacketcaptureCaptureEnum::BIDIRECTIONAL:
      t_in.set(0x0, ON_T);
      t_out.set(0x0, ON_T);
      CapStatus = 2;
    break;
    case PacketcaptureCaptureEnum::OFF:
      t_in.set(0x0, OFF_T);
      t_out.set(0x0, OFF_T);
      CapStatus = 3;
    break;
  }
}

bool Packetcapture::getAnomimize() {
  //TODO
}

void Packetcapture::setAnomimize(const bool &value) {
  //TODO
}

std::string Packetcapture::getDump() {
  std::stringstream dump;

  if(network_mode_flag){
    dump << "the service is running in network mode";
  }else{
      char *cwdr_ptr = get_current_dir_name();
      std::string wdr(cwdr_ptr);
      dump << "capture dump in " << wdr << "/capture_"+ dt +".pcap" << std::endl;
  }
  
  return dump.str();
}

void Packetcapture::setDump(const std::string &value) {
    throw std::runtime_error("Packetcapture::setDump: Method not implemented");
}

bool Packetcapture::getNetworkmode() {
  return network_mode_flag;
}

void Packetcapture::setNetworkmode(const bool &value) {
  network_mode_flag = value;
=======
      
    logger()->debug("Packet received - packet_in. Packet size= {0}", packet.size());

    //ricevuto il pacchetto dal fast path, ricorda che dati reali del pacchetto sono in packet
    packetHeaders pkt_values = get_array_table<packetHeaders>("pkt_header").get(0x0);
    
    //devo prima parsificare e solo poi eventualmente memorizzare
    if( filtering(pkt_values) == true )
    {
      logger()->debug("packet stored");
    }else
    {
      logger()->debug("Packet rejected");
    }
    
}

PacketcaptureCaptureEnum Packetcapture::getCapture() {
  //throw std::runtime_error("Packetcapture::getCapture: Method not implemented");
}

void Packetcapture::setCapture(const PacketcaptureCaptureEnum &value) {
  //throw std::runtime_error("Packetcapture::setCapture: Method not implemented");
}

bool Packetcapture::getAnomimize() {
  //throw std::runtime_error("Packetcapture::getAnomimize: Method not implemented");
}

void Packetcapture::setAnomimize(const bool &value) {
  //throw std::runtime_error("Packetcapture::setAnomimize: Method not implemented");
}

uint32_t Packetcapture::getLinktype() {
  //throw std::runtime_error("Packetcapture::getLinktype: Method not implemented");
}

void Packetcapture::setLinktype(const uint32_t &value) {
  //throw std::runtime_error("Packetcapture::setLinktype: Method not implemented");
}

std::string Packetcapture::getDump() {
  //throw std::runtime_error("Packetcapture::getDump: Method not implemented");
}

void Packetcapture::setDump(const std::string &value) {
  //throw std::runtime_error("Packetcapture::setDump: Method not implemented");
>>>>>>> Packet filters application
}

std::shared_ptr<Filters> Packetcapture::getFilters() {
  return filters;
}

void Packetcapture::addFilters(const FiltersJsonObject &value) {
  filters = std::shared_ptr<Filters>(new Filters(*this, value));
}

void Packetcapture::replaceFilters(const FiltersJsonObject &conf) {
  PacketcaptureBase::replaceFilters(conf);
}

void Packetcapture::delFilters() {
  //throw std::runtime_error("Packetcapture::delFilters: method not implemented");
}

/* return the first packet in the queue if exist */
std::shared_ptr<Packet> Packetcapture::getPacket() {
<<<<<<< HEAD
  if(packets_captured.size() != 0){
    auto p = packets_captured.front();
    if(network_mode_flag){                            /* pop this element */
      packets_captured.erase(packets_captured.begin());
      if(filters->getSnaplen() < p->getPacketlen()){
        p->packet.resize(filters->getSnaplen());
      }
    }
    return p;
  }
  PacketJsonObject pj;
  auto p = std::shared_ptr<Packet>(new Packet(*this, pj));
  return p;
}

void Packetcapture::addPacket(const std::vector<uint8_t> &packet,
    const packetHeaders &pkt_values) {
    PacketJsonObject pj;
    auto p = std::shared_ptr<Packet>(new Packet(*this, pj));
    struct timeval tp;
    gettimeofday(&tp, NULL);
    p->setTimestampSeconds((uint32_t) tp.tv_sec);
    p->setTimestampMicroseconds((uint32_t) tp.tv_usec);
    p->setPacketlen((uint32_t) packet.size());
    if(p->getPacketlen() > filters->getSnaplen()){
      p->setCapturelen(filters->getSnaplen());
    }else{
      p->setCapturelen(p->getPacketlen());
    }
    p->setRawPacketData(packet);
    packets_captured.push_back(p);
=======
  //throw std::runtime_error("Packetcapture::getPacket: Method not implemented");
>>>>>>> Packet filters application
}

void Packetcapture::addPacket(const PacketJsonObject &value) {
  //throw std::runtime_error("Packetcapture::addPacket: Method not implemented");
}

void Packetcapture::replacePacket(const PacketJsonObject &conf) {
  PacketcaptureBase::replacePacket(conf);
}

void Packetcapture::delPacket() {
<<<<<<< HEAD
  throw std::runtime_error("Packetcapture::delPacket: method not implemented");
<<<<<<< HEAD
=======
  //throw std::runtime_error("Packetcapture::delPacket: method not implemented");
>>>>>>> Packet filters application
}

void Packetcapture::attach() {
  dt = std::string("");
  logger()->debug("{0} attached", this->get_name());
}

void Packetcapture::updateFiltersMaps(){
  filters_table ft;
  
  if(filters->l4proto_is_set()){
    ft.l4proto_flag = true;
    filters->getL4proto().compare("tcp") == 0? ft.l4proto_filter = 1 : ft.l4proto_filter = 2;
  }else{
    ft.l4proto_flag = false;
  }

  if(filters->srcPort_is_set()){
    ft.src_port_flag = true;
    ft.src_port_filter = filters->getSport();
  }else{
    ft.src_port_flag = false;
  }

  if(filters->dstPort_is_set()){
    ft.dst_port_flag = true;
    ft.dst_port_filter = filters->getDport();
  }else{
    ft.dst_port_flag = false;
  }

  if(filters->srcIp_is_set()){
    ft.network_filter_src_flag = true;
    ft.network_filter_src = filters->getNetworkFilterSrc();
    ft.netmask_filter_src = filters->getNetmaskFilterSrc();
    logger()->debug("network filter: {0}\nnetmask filter: {1}", ft.network_filter_src, ft.netmask_filter_src);
  }else{
    ft.network_filter_src_flag = false;
  }

  if(filters->dstIp_is_set()){
    ft.network_filter_dst_flag = true;
    ft.network_filter_dst = filters->getNetworkFilterDst();
    ft.netmask_filter_dst = filters->getNetmaskFilterDst();
  }else{
    ft.network_filter_dst_flag = false;
  }

  ft.snaplen = filters->getSnaplen();

  auto ft_fast_in = get_array_table<filters_table>("filters_map", 0, ProgramType::INGRESS);
  auto ft_fast_out = get_array_table<filters_table>("filters_map", 0, ProgramType::EGRESS);

  ft_fast_in.set(0x0, ft);
  ft_fast_out.set(0x0, ft);
}

std::shared_ptr<Globalheader> Packetcapture::getGlobalheader() {
  return global_header;
}

void Packetcapture::addGlobalheader(const GlobalheaderJsonObject &value) {
    global_header = std::shared_ptr<Globalheader>(new Globalheader(*this, value));
    global_header->setSnaplen(filters->getSnaplen());
}

void Packetcapture::replaceGlobalheader(const GlobalheaderJsonObject &conf) {
  PacketcaptureBase::replaceGlobalheader(conf);
}

void Packetcapture::delGlobalheader() {
  throw std::runtime_error("Packetcapture::delGlobalheader: method not implemented");
}
