/**
* packetcapture API generated from packetcapture.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


#include <string>
#include <sys/time.h>
#include <iomanip>
#include <iostream>
#include <fstream>
#include "unistd.h"
#include "Packetcapture.h"
#include "Packetcapture_dp_ingress.h"
#include "Packetcapture_dp_egress.h"
#define ON_T 0
#define OFF_T 1


typedef int bpf_int32; 
typedef u_int bpf_u_int32;


struct pcap_file_header {
  bpf_u_int32 magic;      /* magic number */
  u_short version_major;  /* major version number */
  u_short version_minor;  /* minor version number */
  bpf_int32 thiszone;     /* GMT to local correction */
  bpf_u_int32 sigfigs;    /* accuracy of timestamps */
  bpf_u_int32 snaplen;    /* max length of captured packets, in octets */
  bpf_u_int32 linktype;   /* data link type */
};

struct pcap_pkthdr {
  bpf_u_int32 ts_sec;
  bpf_u_int32 ts_usec;  
  bpf_u_int32 caplen;     /* number of octets of packet saved in file */
  bpf_u_int32 len;        /* actual length of packet */
};

Packetcapture::Packetcapture(const std::string name, const PacketcaptureJsonObject &conf)
  : TransparentCube(conf.getBase(), { packetcapture_code_ingress }, { packetcapture_code_egress }),
    PacketcaptureBase(name) {
  logger()->info("Creating Packetcapture instance");
    setCapture(conf.getCapture());
    setAnomimize(conf.getAnomimize());

  if (conf.dumpIsSet()) {
    setDump(conf.getDump());
  }

  setNetworkmode(conf.getNetworkmode());
  addFilters(conf.getFilters());
  addGlobalheader(conf.getGlobalheader());
  CapStatus = (uint8_t) conf.getCapture();

  auto t_filters_in = get_array_table<filters_table>("filters_map", 0, ProgramType::INGRESS);
  auto t_filters_out = get_array_table<filters_table>("filters_map", 0, ProgramType::EGRESS);
  filters_table ft_init;
  ft_init.dst_port_flag = ft_init.src_port_flag = ft_init.network_filter_src_flag = ft_init.network_filter_dst_flag = ft_init.l4proto_flag = false;
  t_filters_in.set(0x0, ft_init);
  t_filters_out.set(0x0, ft_init);
}


Packetcapture::~Packetcapture() {
  logger()->info("Destroying Packetcapture instance");
}

void Packetcapture::packet_in(polycube::service::Sense sense,
    polycube::service::PacketInMetadata &md,
    const std::vector<uint8_t> &packet) {
  
  Tins::EthernetII pkt(&packet[0], packet.size());
  packetHeaders pkt_values;
      
  switch (sense) {
    case polycube::service::Sense::INGRESS:
    pkt_values = get_array_table<packetHeaders>("pkt_header", 0, ProgramType::INGRESS).get(0x0);
    addPacket(packet, pkt_values);
    break;
    case polycube::service::Sense::EGRESS:
    pkt_values = get_array_table<packetHeaders>("pkt_header", 0, ProgramType::EGRESS).get(0x0);
    addPacket(packet, pkt_values);
    break;
  }
  send_packet_out(pkt, sense, false);
}

PacketcaptureCaptureEnum Packetcapture::getCapture() {
  return static_cast<PacketcaptureCaptureEnum>(CapStatus);
}

void Packetcapture::setCapture(const PacketcaptureCaptureEnum &value) {

  auto t_in = get_array_table<uint8_t>("working", 0, ProgramType::INGRESS);
  auto t_out = get_array_table<uint8_t>("working", 0, ProgramType::EGRESS);

  switch(value){
    case PacketcaptureCaptureEnum::INGRESS:
      t_in.set(0x0, ON_T);
      t_out.set(0x0, OFF_T);
      CapStatus = 0;
    break;
    case PacketcaptureCaptureEnum::EGRESS:
      t_in.set(0x0, OFF_T);
      t_out.set(0x0, ON_T);
      CapStatus = 1;
    break;
    case PacketcaptureCaptureEnum::BIDIRECTIONAL:
      t_in.set(0x0, ON_T);
      t_out.set(0x0, ON_T);
      CapStatus = 2;
    break;
    case PacketcaptureCaptureEnum::OFF:
      t_in.set(0x0, OFF_T);
      t_out.set(0x0, OFF_T);
      CapStatus = 3;
    break;
  }
}

bool Packetcapture::getAnomimize() {
  //TODO
}

void Packetcapture::setAnomimize(const bool &value) {
  //TODO
}

std::string Packetcapture::getDump() {
  std::stringstream dump;
  std::ofstream myFile;
  std::streamsize len;

  if(!packets_captured.empty()){
    if(network_mode_flag){
      dump << "the service is running in network mode";
    }else{
      struct pcap_file_header *pcap_header = new struct pcap_file_header;
      pcap_header->magic = global_header->getMagic();
      pcap_header->version_major = global_header->getVersionMajor();
      pcap_header->version_minor = global_header->getVersionMinor();
      pcap_header->thiszone = global_header->getThiszone();   //timestamp are always in GMT
      pcap_header->sigfigs = global_header->getSigfigs();
      pcap_header->snaplen = filters->getSnaplen();
      pcap_header->linktype = global_header->getLinktype();

      myFile.open("capture.pcap", std::ios::binary);
      myFile.write(reinterpret_cast<const char*>(pcap_header), sizeof(*pcap_header));

      for(auto it = packets_captured.begin(); it != packets_captured.end(); it++){
        std::shared_ptr<Packet> p = *it;
        struct pcap_pkthdr *pkt_hdr = new struct pcap_pkthdr;
        pkt_hdr->ts_sec = p->getTimestampSeconds();
        pkt_hdr->ts_usec = p->getTimestampMicroseconds();
        pkt_hdr->len = p->getPacketlen();
        pkt_hdr->caplen = p->getCapturelen();
        filters->getSnaplen() < p->getRawPacketData().size() ? len = filters->getSnaplen() : len = p->getRawPacketData().size();
          
        myFile.write(reinterpret_cast<const char*>(pkt_hdr), sizeof(*pkt_hdr));
        myFile.write(reinterpret_cast<const char*>(&p->getRawPacketData()[0]), len );
      }

      myFile.close();
      char *cwdr_ptr = get_current_dir_name();
      std::string wdr(cwdr_ptr);
      dump << "capture dump in " << wdr << "/capture.pcap" << std::endl;
    }
    
  }else{
    dump << "no packets captured";
  }
  
  return dump.str();
}

void Packetcapture::setDump(const std::string &value) {
    throw std::runtime_error("Packetcapture::setDump: Method not implemented");
}

bool Packetcapture::getNetworkmode() {
  return network_mode_flag;
}

void Packetcapture::setNetworkmode(const bool &value) {
  network_mode_flag = value;
}

std::shared_ptr<Filters> Packetcapture::getFilters() {
  return filters;
}

void Packetcapture::addFilters(const FiltersJsonObject &value) {
  filters = std::shared_ptr<Filters>(new Filters(*this, value));
}

void Packetcapture::replaceFilters(const FiltersJsonObject &conf) {
  PacketcaptureBase::replaceFilters(conf);
}

void Packetcapture::delFilters() {
  throw std::runtime_error("Packetcapture::delFilters: method not implemented");
}

/* return the first packet in the queue if exist */
std::shared_ptr<Packet> Packetcapture::getPacket() {
  if(packets_captured.size() != 0){
    auto p = packets_captured.front();
    if(network_mode_flag){                            /* pop this element */
      packets_captured.erase(packets_captured.begin());
      if(filters->getSnaplen() < p->getPacketlen()){
        p->packet.resize(filters->getSnaplen());
      }
    }
    return p;
  }
  PacketJsonObject pj;
  auto p = std::shared_ptr<Packet>(new Packet(*this, pj));
  return p;
}

void Packetcapture::addPacket(const std::vector<uint8_t> &packet,
    const packetHeaders &pkt_values) {
    PacketJsonObject pj;
    auto p = std::shared_ptr<Packet>(new Packet(*this, pj));
    struct timeval tp;
    gettimeofday(&tp, NULL);
    p->setTimestampSeconds((uint32_t) tp.tv_sec);
    p->setTimestampMicroseconds((uint32_t) tp.tv_usec);
    p->setPacketlen((uint32_t) packet.size());
    if(p->getPacketlen() > filters->getSnaplen()){
      p->setCapturelen(filters->getSnaplen());
    }else{
      p->setCapturelen(p->getPacketlen());
    }
    p->setRawPacketData(packet);
    packets_captured.push_back(p);
}

void Packetcapture::addPacket(const PacketJsonObject &value) {
  throw std::runtime_error("Packetcapture::addPacket: Method not implemented");
}

void Packetcapture::replacePacket(const PacketJsonObject &conf) {
  PacketcaptureBase::replacePacket(conf);
}

void Packetcapture::delPacket() {
  throw std::runtime_error("Packetcapture::delPacket: method not implemented");
}

void Packetcapture::attach() {
  logger()->debug("{0} attached", this->get_name());
}

void Packetcapture::updateFiltersMaps(){
  filters_table ft;
  
  if(filters->l4proto_is_set()){
    ft.l4proto_flag = true;
    filters->getL4proto().compare("tcp") == 0? ft.l4proto_filter = 1 : ft.l4proto_filter = 2;
  }else{
    ft.l4proto_flag = false;
  }

  if(filters->srcPort_is_set()){
    ft.src_port_flag = true;
    ft.src_port_filter = filters->getSport();
  }else{
    ft.src_port_flag = false;
  }

  if(filters->dstPort_is_set()){
    ft.dst_port_flag = true;
    ft.dst_port_filter = filters->getDport();
  }else{
    ft.dst_port_flag = false;
  }

  if(filters->srcIp_is_set()){
    ft.network_filter_src_flag = true;
    ft.network_filter_src = filters->getNetworkFilterSrc();
    ft.netmask_filter_src = filters->getNetmaskFilterSrc();
    logger()->debug("network filter: {0}\nnetmask filter: {1}", ft.network_filter_src, ft.netmask_filter_src);
  }else{
    ft.network_filter_src_flag = false;
  }

  if(filters->dstIp_is_set()){
    ft.network_filter_dst_flag = true;
    ft.network_filter_dst = filters->getNetworkFilterDst();
    ft.netmask_filter_dst = filters->getNetmaskFilterDst();
  }else{
    ft.network_filter_dst_flag = false;
  }

  ft.snaplen = filters->getSnaplen();

  auto ft_fast_in = get_array_table<filters_table>("filters_map", 0, ProgramType::INGRESS);
  auto ft_fast_out = get_array_table<filters_table>("filters_map", 0, ProgramType::EGRESS);

  ft_fast_in.set(0x0, ft);
  ft_fast_out.set(0x0, ft);
}

std::shared_ptr<Globalheader> Packetcapture::getGlobalheader() {
  return global_header;
}

void Packetcapture::addGlobalheader(const GlobalheaderJsonObject &value) {
    global_header = std::shared_ptr<Globalheader>(new Globalheader(*this, value));
    global_header->setSnaplen(filters->getSnaplen());
}

void Packetcapture::replaceGlobalheader(const GlobalheaderJsonObject &conf) {
  PacketcaptureBase::replaceGlobalheader(conf);
}

void Packetcapture::delGlobalheader() {
  throw std::runtime_error("Packetcapture::delGlobalheader: method not implemented");
}