/**
* packetcapture API generated from packetcapture.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


<<<<<<< HEAD
#include "Filters.h"
#include "Packetcapture.h"
#include "Packetcapture_dp_ingress.h"
#include "Packetcapture_dp_egress.h"



Filters::Filters(Packetcapture &parent, const FiltersJsonObject &conf)
    : FiltersBase(parent), set_dstIp(false), set_srcIp(false), set_dstPort(false), set_srcPort(false), set_l4proto(false) {

=======
// TODO: Modify these methods with your own implementation


#include "Filters.h"
#include "Packetcapture.h"


Filters::Filters(Packetcapture &parent, const FiltersJsonObject &conf)
    : FiltersBase(parent) {
>>>>>>> Data model and packetcapture stub created
  if (conf.snaplenIsSet()) {
    setSnaplen(conf.getSnaplen());
  }

  if (conf.srcIsSet()) {
    setSrc(conf.getSrc());
  }

  if (conf.dstIsSet()) {
    setDst(conf.getDst());
  }

  if (conf.l4protoIsSet()) {
    setL4proto(conf.getL4proto());
  }

  if (conf.sportIsSet()) {
    setSport(conf.getSport());
  }

  if (conf.dportIsSet()) {
    setDport(conf.getDport());
  }
<<<<<<< HEAD
  bootstrap = false;
  snaplen = 262144;
=======

>>>>>>> Data model and packetcapture stub created
}

Filters::~Filters() {}

uint32_t Filters::getSnaplen() {
<<<<<<< HEAD
  return snaplen;
}

void Filters::setSnaplen(const uint32_t &value) {
  snaplen = value;
  set_snaplen = true;
  if(!bootstrap)
    parent_.updateFiltersMaps();
}

std::string Filters::getSrc() {
  return srcIp;
}

void Filters::setSrc(const std::string &value) {
  srcIp = value;

  uint32_t ip_src_filter = 0;
  netmaskSrc = (0xFFFFFFFF << (32 - std::stoi(value.substr(value.find("/")+1)))) & 0xFFFFFFFF;
  std::string source_ip = value.substr(0, value.find("/"));
  inet_pton(AF_INET, source_ip.data(), &ip_src_filter);
  ip_src_filter = ntohl(ip_src_filter);
  networkSrc = ip_src_filter & netmaskSrc;
  //network_packet = pkt_values.srcIp & netmask_filter;     //TODO: do it in the fast path

  set_srcIp = true;
  if(!bootstrap)
    parent_.updateFiltersMaps();
}

std::string Filters::getDst() {
  return dstIp;
}

void Filters::setDst(const std::string &value) {
  dstIp = value;

  uint32_t ip_dst_filter = 0;
  netmaskDst = (0xFFFFFFFF << (32 - std::stoi(value.substr(value.find("/")+1)))) & 0xFFFFFFFF;
  std::string source_ip = value.substr(0, value.find("/"));
  inet_pton(AF_INET, source_ip.data(), &ip_dst_filter);
  ip_dst_filter = ntohl(ip_dst_filter);
  networkDst = ip_dst_filter & netmaskDst;
  //network_packet = pkt_values.dstIp & netmask_filter;     //TODO: do it in the fast path

  set_dstIp = true;
  if(!bootstrap)
    parent_.updateFiltersMaps();
}

std::string Filters::getL4proto() {
  return l4proto;
}

void Filters::setL4proto(const std::string &value) {
  if((value.compare(std::string("tcp")) == 0) || (value.compare(std::string("udp")) == 0)){
    l4proto = value;
    set_l4proto = true;
    if(!bootstrap)
      parent_.updateFiltersMaps();
  }else
    throw std::runtime_error("Bad value at setL4proto. Please enter 'tcp' or 'udp'");
}

uint16_t Filters::getSport() {
  return this->srcPort;
}

void Filters::setSport(const uint16_t &value) {
  srcPort = value;
  set_srcPort = true;
  if(!bootstrap)
    parent_.updateFiltersMaps();
}

uint16_t Filters::getDport() {
  return dstPort;
}

void Filters::setDport(const uint16_t &value) {
  dstPort = value;
  set_dstPort = true;
  if(!bootstrap)
    parent_.updateFiltersMaps();
}

uint32_t Filters::getNetworkFilterSrc(){
  return networkSrc;
}

uint32_t Filters::getNetworkFilterDst(){
  return networkDst;
}

uint32_t Filters::getNetmaskFilterSrc(){
  return netmaskSrc;
}

uint32_t Filters::getNetmaskFilterDst(){
  return netmaskDst;
}
=======
  throw std::runtime_error("Filters::getSnaplen: Method not implemented");
}

void Filters::setSnaplen(const uint32_t &value) {
  throw std::runtime_error("Filters::setSnaplen: Method not implemented");
}

std::string Filters::getSrc() {
  throw std::runtime_error("Filters::getSrc: Method not implemented");
}

void Filters::setSrc(const std::string &value) {
  throw std::runtime_error("Filters::setSrc: Method not implemented");
}

std::string Filters::getDst() {
  throw std::runtime_error("Filters::getDst: Method not implemented");
}

void Filters::setDst(const std::string &value) {
  throw std::runtime_error("Filters::setDst: Method not implemented");
}

std::string Filters::getL4proto() {
  throw std::runtime_error("Filters::getL4proto: Method not implemented");
}

void Filters::setL4proto(const std::string &value) {
  throw std::runtime_error("Filters::setL4proto: Method not implemented");
}

uint16_t Filters::getSport() {
  throw std::runtime_error("Filters::getSport: Method not implemented");
}

void Filters::setSport(const uint16_t &value) {
  throw std::runtime_error("Filters::setSport: Method not implemented");
}

uint16_t Filters::getDport() {
  throw std::runtime_error("Filters::getDport: Method not implemented");
}

void Filters::setDport(const uint16_t &value) {
  throw std::runtime_error("Filters::setDport: Method not implemented");
}


>>>>>>> Data model and packetcapture stub created
